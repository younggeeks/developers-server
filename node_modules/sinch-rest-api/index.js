var sinchRequest = require('sinch-request')
var assert = require('assert-plus');
var https = require('https');
var Q = require('q');
var PAPI = require('./papi/_index.js');

var restRequest = function(credentials, environment) {
	assert.object(credentials, 'credentials');

	this._creds = [credentials];

	this._environment = environment || {
		base: 'api.sinch.com',
		user: 'userapi.sinch.com',
		calling: 'callingapi.sinch.com',
		messaging: 'messagingapi.sinch.com',
		verification: 'api.sinch.com',
		portal: 'portalapi.sinch.com',
		reporting: 'reportingapi.sinch.com'
	};

	this._PAPI = JSON.parse(JSON.stringify(PAPI)); 
	for(var api in PAPI) {
		this[api] = {};
		for(var key in PAPI[api]) {
			this._PAPI[api][key].urlParts = (this._PAPI[api][key].url).split('/');
			this[api][key] = requestPrototype.bind(this, api, key);
		};
	};
}

restRequest.prototype.pushInstance = function(instanceCredentials) {
	assert.object(instanceCredentials, 'instanceCredentials');

	instanceCredentials.key = instanceCredentials.key || instanceCredentials.id;
	this._creds.push(instanceCredentials);

	return instanceCredentials;
}

restRequest.prototype.popInstance = function() {
	return this._creds.pop();
}

var sinchAjax = function(configObj) {
	var deferred = Q.defer();

	var req = https.request(configObj, function(response) {
		var data = '';
		response.on('data', function (chunk) {
			data += chunk;
		});
		response.on('end', function () {
			try {
				data = JSON.parse(data);
			}
			catch(e) {}
			finally {
				if(response.statusCode >= 200 && response.statusCode < 300) {
					deferred.resolve(data);
				}
				else {
					deferred.reject(data);
				}
			}
		});
		response.on('error', function() {
			deferred.reject(new Error('Unsupported operation'));
		})
	});

	req.end(configObj.data);

	return deferred.promise;
};

var requestPrototype = function(api, key, data) {
	var papi = this._PAPI[api][key];

	var configObj = {
		host: this._environment[api],
		method: papi.method,
		withCredentials: false,
		port: 443
	};

	if(papi.method != 'GET') {
		configObj.data = (typeof data !== 'string' ? JSON.stringify(data) : data);
	}

	configObj.path = '';
	for(var partIdx in papi.urlParts) {
		if(papi.urlParts[partIdx][0] === ':') {
			var param = papi.urlParts[partIdx].slice(1);
			configObj.path += (data || {})[param];
		}
		else {
			configObj.path += papi.urlParts[partIdx];
		}
		if(partIdx < papi.urlParts.length-1) {
			configObj.path += '/';
		}
	};

	var credentials = this._creds[this._creds.length - 1];
	switch(papi.auth) {
		case 'sign':
			if(this._creds.length > 1) {
				sinchRequest.instanceSigned(configObj, credentials);
			}
			else {
				sinchRequest.applicationSigned(configObj, credentials);
			}
			break;
		case 'nosign':
			sinchRequest.applicationBasic(configObj, credentials);
			break;
		case 'ticket':
			var ticket = data.authorization;
			delete data['authorization'];
			data.version = data.version || {os: 'js', platform: 'NodeJS'};
			configObj.data = JSON.stringify(data);
			sinchRequest.ticket(configObj, ticket);
			break;
		default: 
			throw new Error('Unsupported authentication type: ' + papi.auth);
	}

	//Append query parameters
	if(papi.method === 'GET' && data && Object.keys(data).length > 0) {
		configObj.path += '?';
		for(var key in data) {
			configObj.path += encodeURIComponent(key) + '=' + encodeURIComponent(data[key]) + '&';
		}
	}

	return sinchAjax(configObj);
}

module.exports = function(credentials, environment) {
	assert.object(credentials, 'credentials');
	return new restRequest(credentials, environment)
};

